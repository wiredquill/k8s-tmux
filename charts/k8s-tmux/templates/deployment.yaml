apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Values.deploymentName | default (include "k8s-tmux.fullname" .) }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "k8s-tmux.labels" . | nindent 4 }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      {{- include "k8s-tmux.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      labels:
        {{- include "k8s-tmux.selectorLabels" . | nindent 8 }}
    spec:
      {{- with .Values.podSecurityContext }}
      securityContext:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      serviceAccountName: {{ include "k8s-tmux.serviceAccountName" . }}
      containers:
      - name: {{ .Chart.Name }}
        {{- with .Values.securityContext }}
        securityContext:
          {{- toYaml . | nindent 10 }}
        {{- end }}
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        command: ["/bin/bash"]
        args:
        - "-c"
        - |
          # Create uploads directory in home folder
          mkdir -p {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/uploads
          chown -R {{ .Values.session.user }}:{{ .Values.session.user }} {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/uploads 2>/dev/null || echo "Note: Could not change ownership of uploads directory"
          chmod 755 {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/uploads
          
          # Install MQTT client tools - try multiple approaches
          echo "Installing MQTT client tools..."
          zypper refresh && zypper install -y mosquitto-clients 2>/dev/null || \
          apt-get update && apt-get install -y mosquitto-clients 2>/dev/null || \
          yum install -y mosquitto-clients 2>/dev/null || \
          echo "MQTT client install failed, will use fallback method"
          
          # Setup home directory and user environment
          echo "Setting up user environment..."
          mkdir -p {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/.kube {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/.ssh {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/bin
          chown -R {{ .Values.session.user }}:{{ .Values.session.user }} {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }} 2>/dev/null || echo "Note: Using existing file permissions"
          
          {{- if .Values.kubernetesTools.kubectx.enabled }}
          # Install kubectx/kubens for Kubernetes context switching
          echo "Installing kubectx/kubens..."
          curl -L https://github.com/ahmetb/kubectx/releases/latest/download/kubectx -o {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/bin/kubectx
          curl -L https://github.com/ahmetb/kubectx/releases/latest/download/kubens -o {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/bin/kubens
          chmod +x {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/bin/kubectx {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/bin/kubens
          {{- end }}
          
          {{- if and .Values.kubernetesTools.kubectx.enabled .Values.kubernetesTools.kubectx.autoDetectConfigs }}
          # Create kubectx automation script
          cat > {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/bin/load-kube-configs << 'EOF'
          #!/bin/bash
          # Auto-detect and merge all kubeconfig files in ~/.kube directory
          KUBE_DIR="$HOME/.kube"
          MERGED_CONFIG="$KUBE_DIR/config"
          
          if [ -d "$KUBE_DIR" ]; then
              echo "🔍 Scanning for Kubernetes config files in $KUBE_DIR..."
              
              # Find all .yaml and .yml files
              CONFIG_FILES=$(find "$KUBE_DIR" -name "*.yaml" -o -name "*.yml" | grep -v "^$MERGED_CONFIG$" | sort)
              
              if [ -n "$CONFIG_FILES" ]; then
                  echo "📋 Found config files:"
                  echo "$CONFIG_FILES" | sed 's/^/  - /'
                  
                  # Backup existing config if it exists
                  if [ -f "$MERGED_CONFIG" ]; then
                      cp "$MERGED_CONFIG" "$MERGED_CONFIG.backup.$(date +%Y%m%d-%H%M%S)"
                  fi
                  
                  # Merge all configs
                  export KUBECONFIG=$(echo "$CONFIG_FILES" | tr '\n' ':' | sed 's/:$//')
                  if [ -f "$MERGED_CONFIG" ]; then
                      export KUBECONFIG="$MERGED_CONFIG:$KUBECONFIG"
                  fi
                  
                  kubectl config view --flatten > "$MERGED_CONFIG.tmp" && mv "$MERGED_CONFIG.tmp" "$MERGED_CONFIG"
                  chmod 600 "$MERGED_CONFIG"
                  
                  echo "✅ Merged $(echo "$CONFIG_FILES" | wc -l) config files into $MERGED_CONFIG"
                  echo "📊 Available contexts:"
                  kubectl config get-contexts --no-headers | sed 's/^/  /'
              else
                  echo "ℹ️  No additional config files found in $KUBE_DIR"
              fi
          fi
          EOF
          chmod +x {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/bin/load-kube-configs
          {{- end }}
          
          {{- if .Values.devTools.claudeCode.enabled }}
          # Install Claude Code CLI
          echo "Installing Claude Code CLI..."
          {{ .Values.devTools.claudeCode.installScript }}
          {{- end }}
          
          # Setup shell environment
          cat >> {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/.bashrc << 'EOF'
          # Add user bin to PATH
          export PATH="$HOME/bin:$PATH"
          
          {{- if .Values.kubernetesTools.kubectx.enabled }}
          # Kubernetes tools aliases
          alias k=kubectl
          alias kx=kubectx
          alias kn=kubens
          {{- end }}
          
          {{- if and .Values.kubernetesTools.kubectx.enabled .Values.kubernetesTools.kubectx.autoDetectConfigs }}
          # Auto-load kube configs on shell start
          if [ -x "$HOME/bin/load-kube-configs" ]; then
              $HOME/bin/load-kube-configs
          fi
          {{- end }}
          
          # Set default kubeconfig
          export KUBECONFIG="$HOME/.kube/config"
          
          {{- if .Values.devTools.claudeCode.enabled }}
          # Claude Code integration (if installed)
          if command -v claude &> /dev/null; then
              echo "🤖 Claude Code CLI available"
          fi
          {{- end }}
          
          {{- if .Values.devTools.git.enabled }}
          {{- if .Values.devTools.git.userName }}
          # Configure Git user
          git config --global user.name "{{ .Values.devTools.git.userName }}"
          {{- end }}
          {{- if .Values.devTools.git.userEmail }}
          git config --global user.email "{{ .Values.devTools.git.userEmail }}"
          {{- end }}
          {{- end }}
          
          {{- if .Values.github.enabled }}
          {{- if and .Values.github.username .Values.github.token }}
          # Configure GitHub CLI
          echo "{{ .Values.github.token }}" | gh auth login --with-token
          gh auth setup-git
          {{- end }}
          {{- end }}
          EOF
          
          # Copy bashrc to zshrc for zsh users
          cp {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/.bashrc {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/.zshrc
          
          # Set ownership
          chown -R {{ .Values.session.user }}:{{ .Values.session.user }} {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }} 2>/dev/null || echo "Note: Using existing file permissions"
          
          export TERM=xterm-256color
          export COLORTERM=truecolor
          export FORCE_COLOR=1
          export CLICOLOR_FORCE=1
          
          # Ensure dev user exists with proper shell access
          if ! id {{ .Values.session.user }} &>/dev/null; then
              useradd -m -s /bin/bash {{ .Values.session.user }} 2>/dev/null || echo "User {{ .Values.session.user }} creation skipped"
          fi
          
          # Check if we're already running as the target user
          CURRENT_USER=$(whoami)
          if [ "$CURRENT_USER" = "{{ .Values.session.user }}" ]; then
              echo "Already running as {{ .Values.session.user }}, creating tmux session directly"
              cd {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}
              tmux new-session -d -s main -c {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }} bash 2>/dev/null || echo "tmux session creation failed or already exists"
              tmux send-keys -t main 'export TERM=xterm-256color' Enter 2>/dev/null || echo "Could not configure tmux TERM"
              tmux send-keys -t main 'clear' Enter 2>/dev/null || echo "Could not clear tmux"
          else
              echo "Running as $CURRENT_USER, attempting to switch to {{ .Values.session.user }}"
              # Switch to dev user and start tmux in home directory
              runuser -l {{ .Values.session.user }} -c "cd {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }} && tmux new-session -d -s main -c {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }} bash" 2>/dev/null || \
              su - {{ .Values.session.user }} -c "cd {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }} && tmux new-session -d -s main -c {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }} bash" 2>/dev/null || \
              echo "Warning: Could not switch to {{ .Values.session.user }}, running as root"
              
              runuser -l {{ .Values.session.user }} -c "tmux send-keys -t main 'export TERM=xterm-256color' Enter" 2>/dev/null || \
              su - {{ .Values.session.user }} -c "tmux send-keys -t main 'export TERM=xterm-256color' Enter" 2>/dev/null || \
              echo "Warning: Could not configure tmux as {{ .Values.session.user }}"
              
              runuser -l {{ .Values.session.user }} -c "tmux send-keys -t main 'clear' Enter" 2>/dev/null || \
              su - {{ .Values.session.user }} -c "tmux send-keys -t main 'clear' Enter" 2>/dev/null || \
              echo "Warning: Could not clear tmux as {{ .Values.session.user }}"
          fi
          
          echo "Starting ttyd..."
          # Start ttyd with appropriate user context
          if [ "$CURRENT_USER" = "{{ .Values.session.user }}" ]; then
              /usr/local/bin/ttyd --port 7681 --interface 0.0.0.0 --writable --terminal-type xterm-256color tmux attach-session -t main > /tmp/ttyd.log 2>&1 &
          else
              /usr/local/bin/ttyd --port 7681 --interface 0.0.0.0 --writable --terminal-type xterm-256color runuser -l {{ .Values.session.user }} -c "tmux attach-session -t main" > /tmp/ttyd.log 2>&1 || \
              /usr/local/bin/ttyd --port 7681 --interface 0.0.0.0 --writable --terminal-type xterm-256color su - {{ .Values.session.user }} -c "tmux attach-session -t main" > /tmp/ttyd.log 2>&1 || \
              /usr/local/bin/ttyd --port 7681 --interface 0.0.0.0 --writable --terminal-type xterm-256color bash > /tmp/ttyd.log 2>&1 &
          fi
          TTYD_PID=$!
          
          sleep 3
          if ps -p $TTYD_PID > /dev/null; then
            echo "ttyd started successfully (PID: $TTYD_PID)"
          else
            echo "ERROR: ttyd failed to start"
          fi
          
          # Create Python server for web UI and file management
          cat > /tmp/server.py << 'PYEOF'
          #!/usr/bin/env python3
          import http.server
          import socketserver
          import urllib.parse
          import json
          import os
          import subprocess
          import time
          import socket
          import struct
          import cgi
          import shutil
          from io import BytesIO
          
          class FileHandler(http.server.SimpleHTTPRequestHandler):
              def do_GET(self):
                  if self.path == '/':
                      self.send_ui()
                  elif self.path.startswith('/api/files'):
                      self.send_file_list()
                  elif self.path.startswith('/api/download'):
                      self.handle_download()
                  elif self.path == '/terminal':
                      self.redirect_to_ttyd()
                  else:
                      super().do_GET()
              
              def do_POST(self):
                  if self.path == '/api/upload':
                      self.handle_file_upload()
                  else:
                      self.send_error(404)
              
              def redirect_to_ttyd(self):
                  host = self.headers.get('Host', 'localhost').split(':')[0]
                  self.send_response(302)
                  self.send_header('Location', f'http://{host}:7681')
                  self.end_headers()
              
              def handle_file_upload(self):
                  try:
                      content_type = self.headers.get('Content-Type', '')
                      
                      if 'multipart/form-data' in content_type:
                          form = cgi.FieldStorage(
                              fp=self.rfile,
                              headers=self.headers,
                              environ={'REQUEST_METHOD': 'POST'}
                          )
                          
                          if 'file' not in form:
                              self.send_error(400, "No file uploaded")
                              return
                          
                          file_item = form['file']
                          if not file_item.filename:
                              self.send_error(400, "No file selected")
                              return
                          
                          # Save file to uploads directory in home folder
                          upload_dir = '{{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}/uploads'
                          os.makedirs(upload_dir, exist_ok=True)
                          
                          filename = file_item.filename
                          filepath = os.path.join(upload_dir, filename)
                          
                          with open(filepath, 'wb') as f:
                              shutil.copyfileobj(file_item.file, f)
                          
                          response = {
                              "status": "success", 
                              "message": f"File '{filename}' uploaded successfully",
                              "filename": filename,
                              "size": os.path.getsize(filepath)
                          }
                      else:
                          self.send_error(400, "Invalid content type")
                          return
                      
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps(response).encode())
                      
                  except Exception as e:
                      self.send_error(500, f"Upload error: {e}")
              
              def handle_download(self):
                  try:
                      query = urllib.parse.urlparse(self.path).query
                      params = urllib.parse.parse_qs(query)
                      file_path = params.get('path', [''])[0]
                      
                      if not file_path:
                          self.send_error(400, "No file path provided")
                          return
                      
                      # Security: ensure path is within allowed directories
                      base_dirs = ['/mnt', '{{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}']
                      full_path = os.path.abspath(file_path)
                      
                      allowed = False
                      for base_dir in base_dirs:
                          if full_path.startswith(base_dir):
                              allowed = True
                              break
                      
                      if not allowed:
                          self.send_error(403, "Access denied")
                          return
                      
                      if not os.path.exists(full_path) or os.path.isdir(full_path):
                          self.send_error(404, "File not found or is directory")
                          return
                      
                      file_size = os.path.getsize(full_path)
                      filename = os.path.basename(full_path)
                      
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/octet-stream')
                      self.send_header('Content-Disposition', f'attachment; filename="{filename}"')
                      self.send_header('Content-Length', str(file_size))
                      self.end_headers()
                      
                      with open(full_path, 'rb') as f:
                          while True:
                              chunk = f.read(8192)
                              if not chunk:
                                  break
                              self.wfile.write(chunk)
                      
                  except Exception as e:
                      self.send_error(500, f"Download error: {e}")
              
              def send_file_list(self):
                  try:
                      query = urllib.parse.urlparse(self.path).query
                      params = urllib.parse.parse_qs(query)
                      path_param = params.get('path', [''])[0]
                      
                      # Allow browsing /mnt and home directory
                      base_dirs = ['/mnt', '{{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}']
                      if not path_param:
                          # Show root directories
                          files = []
                          for base_dir in base_dirs:
                              if os.path.exists(base_dir):
                                  files.append({"name": os.path.basename(base_dir) or base_dir, "type": "dir", "path": base_dir, "size": 0})
                      else:
                          full_path = os.path.abspath(path_param)
                          
                          # Verify access
                          allowed = False
                          for base_dir in base_dirs:
                              if full_path.startswith(base_dir):
                                  allowed = True
                                  break
                          
                          if not allowed or not os.path.exists(full_path):
                              self.send_error(404, "Path not found")
                              return
                          
                          files = []
                          # Add parent directory link if not at root
                          if path_param != '/':
                              parent_path = os.path.dirname(path_param)
                              files.append({"name": "..", "type": "dir", "path": parent_path, "size": 0})
                          
                          for item in os.listdir(full_path):
                              item_path = os.path.join(full_path, item)
                              
                              if os.path.isdir(item_path):
                                  files.append({"name": item, "type": "dir", "path": item_path, "size": 0})
                              else:
                                  try:
                                      size = os.path.getsize(item_path)
                                  except:
                                      size = 0
                                  files.append({"name": item, "type": "file", "path": item_path, "size": size})
                      
                      files.sort(key=lambda x: (x['name'] != '..', x['type'] != 'dir', x['name'].lower()))
                      response_data = {"files": files, "current_path": path_param}
                      
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')
                      self.send_header('Access-Control-Allow-Origin', '*')
                      self.end_headers()
                      self.wfile.write(json.dumps(response_data).encode())
                      
                  except Exception as e:
                      self.send_error(500, f"Server error: {e}")
              
              def send_ui(self):
                  session_name = os.environ.get('SESSION_NAME', 'AI Terminal')
                  session_color = os.environ.get('SESSION_COLOR', '#667eea')
                  
                  html = '''<!DOCTYPE html>
          <html>
          <head>
              <title>{session_name}</title>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <style>
                  body { font: sans-serif; margin: 0; background: #f5f7fa; }
                  .container { height: 100vh; display: flex; flex-direction: column; background: white; }
                  .header { background: linear-gradient(135deg, {session_color} 0%, {session_color}dd 100%); color: white; padding: 16px; display: flex; justify-content: space-between; align-items: center; }
                  .header h1 { margin: 0; font-size: 18px; font-weight: 600; }
                  .main-content { flex: 1; display: flex; overflow: hidden; }
                  .terminal-section { flex: 1; position: relative; }
                  .sidebar { width: 320px; padding: 16px; background: #f8fafc; overflow-y: auto; border-left: 1px solid #e2e8f0; }
                  .section { background: white; border-radius: 8px; padding: 16px; margin-bottom: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                  .section-title { font-weight: 600; margin-bottom: 12px; color: #2d3748; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; }
                  .file-browser { max-height: 200px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 6px; padding: 8px; background: #f7fafc; }
                  .file-item { padding: 8px 12px; cursor: pointer; border-radius: 4px; display: flex; align-items: center; gap: 8px; transition: all 0.15s ease; }
                  .file-item:hover { background: #edf2f7; transform: translateX(2px); }
                  .terminal-frame { width: 100%; height: 100%; border: none; background: #000; }
                  .btn { background: {session_color}; color: white; border: none; padding: 12px 16px; border-radius: 6px; cursor: pointer; margin: 4px 2px; font-size: 14px; font-weight: 500; transition: all 0.15s ease; }
                  .btn:hover { background: {session_color}dd; transform: translateY(-1px); }
                  .upload-area { border: 2px dashed #e2e8f0; border-radius: 8px; padding: 20px; text-align: center; margin: 10px 0; transition: all 0.3s ease; background: #fafafa; cursor: pointer; }
                  .upload-area.dragover { border-color: {session_color}; background: rgba(102, 126, 234, 0.1); }
                  .upload-area:hover { border-color: #cbd5e0; }
                  .file-input { display: none; }
                  .debug { font-size: 11px; background: #f0f0f0; padding: 8px; border-radius: 4px; margin-top: 8px; color: #666; word-break: break-all; }
                  .drop-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(102, 126, 234, 0.9); color: white; display: none; align-items: center; justify-content: center; font-size: 24px; z-index: 1000; }
                  .drop-overlay.show { display: flex; }
              </style>
          </head>
          <body>
              <div class="drop-overlay" id="dropOverlay">
                  <div>📁 Drop files here to upload</div>
              </div>
              
              <div class="container">
                  <div class="header">
                      <h1>🤖 {session_name}</h1>
                      <div>
                          <button class="btn" onclick="refreshFiles()">🔄 Refresh</button>
                          <button class="btn" onclick="window.open('/terminal', '_blank')">🖥️ Terminal</button>
                      </div>
                  </div>
                  
                  <div class="main-content">
                      <div class="terminal-section">
                          <iframe class="terminal-frame" src="http://' + window.location.hostname + ':7681"></iframe>
                      </div>
                      
                      <div class="sidebar">
                          <div class="section">
                              <div class="section-title">File Browser</div>
                              <div class="file-browser" id="fileBrowser">
                                  <div style="text-align: center; padding: 20px; color: #718096;">Loading files...</div>
                              </div>
                              <div class="debug" id="debugInfo">Debug info...</div>
                          </div>
                          
                          <div class="section">
                              <div class="section-title">File Upload</div>
                              <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                                  <div>📤 Click or drag files here to upload</div>
                                  <div style="font-size: 12px; color: #666; margin-top: 5px;">Files will be uploaded to uploads directory</div>
                              </div>
                              <input type="file" id="fileInput" class="file-input" multiple onchange="uploadFiles(this.files)">
                              <div id="uploadStatus" class="debug" style="display: none;"></div>
                          </div>
                      </div>
                  </div>
              </div>
              
              <script>
                  let currentPath = '';
                  let dragCounter = 0;
                  
                  function log(msg) {
                      const timestamp = new Date().toLocaleTimeString();
                      const debugEl = document.getElementById('debugInfo');
                      if (debugEl) {
                          debugEl.textContent = timestamp + ': ' + msg;
                      }
                      console.log('[AI-TERMINAL] ' + timestamp + ': ' + msg);
                  }
                  
                  function uploadFiles(files) {
                      if (!files || files.length === 0) return;
                      
                      const statusEl = document.getElementById('uploadStatus');
                      statusEl.style.display = 'block';
                      statusEl.textContent = 'Uploading ' + files.length + ' file(s)...';
                      statusEl.style.backgroundColor = '#bee3f8';
                      
                      Array.from(files).forEach((file, index) => {
                          const formData = new FormData();
                          formData.append('file', file);
                          
                          fetch('/api/upload', {
                              method: 'POST',
                              body: formData
                          })
                          .then(response => response.json())
                          .then(data => {
                              if (data.status === 'success') {
                                  statusEl.textContent = '✅ Uploaded: ' + data.filename + ' (' + Math.round(data.size/1024) + 'KB)';
                                  statusEl.style.backgroundColor = '#c6f6d5';
                                  log('File uploaded: ' + data.filename);
                              } else {
                                  statusEl.textContent = '❌ Upload failed: ' + data.message;
                                  statusEl.style.backgroundColor = '#fed7d7';
                              }
                          })
                          .catch(error => {
                              statusEl.textContent = '❌ Upload error: ' + error.message;
                              statusEl.style.backgroundColor = '#fed7d7';
                              log('Upload error: ' + error.message);
                          });
                      });
                  }
                  
                  // Drag and Drop Event Handlers
                  document.addEventListener('dragenter', function(e) {
                      e.preventDefault();
                      dragCounter++;
                      document.getElementById('dropOverlay').classList.add('show');
                  });
                  
                  document.addEventListener('dragleave', function(e) {
                      e.preventDefault();
                      dragCounter--;
                      if (dragCounter === 0) {
                          document.getElementById('dropOverlay').classList.remove('show');
                      }
                  });
                  
                  document.addEventListener('dragover', function(e) {
                      e.preventDefault();
                  });
                  
                  document.addEventListener('drop', function(e) {
                      e.preventDefault();
                      dragCounter = 0;
                      document.getElementById('dropOverlay').classList.remove('show');
                      
                      const files = e.dataTransfer.files;
                      if (files.length > 0) {
                          uploadFiles(files);
                      }
                  });
                  
                  // Upload area specific handlers
                  const uploadArea = document.getElementById('uploadArea');
                  uploadArea.addEventListener('dragover', function(e) {
                      e.preventDefault();
                      e.stopPropagation();
                      uploadArea.classList.add('dragover');
                  });
                  
                  uploadArea.addEventListener('dragleave', function(e) {
                      e.preventDefault();
                      e.stopPropagation();
                      uploadArea.classList.remove('dragover');
                  });
                  
                  uploadArea.addEventListener('drop', function(e) {
                      e.preventDefault();
                      e.stopPropagation();
                      uploadArea.classList.remove('dragover');
                      
                      const files = e.dataTransfer.files;
                      if (files.length > 0) {
                          uploadFiles(files);
                      }
                  });
                  
                  function loadFiles(path = '') {
                      try {
                          log('Loading files for path: "' + path + '"');
                          
                          const browser = document.getElementById('fileBrowser');
                          if (browser) {
                              browser.innerHTML = '<div style="text-align: center; padding: 20px; color: #718096;">🔄 Loading files...</div>';
                          }
                          
                          const url = path ? '/api/files?path=' + encodeURIComponent(path) + '&t=' + Date.now() : '/api/files?t=' + Date.now();
                          
                          fetch(url, {
                              method: 'GET',
                              headers: {
                                  'Accept': 'application/json',
                                  'Cache-Control': 'no-cache'
                              }
                          })
                          .then(response => {
                              if (!response.ok) {
                                  throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                              }
                              return response.json();
                          })
                          .then(data => {
                              log('Files received: ' + (data.files ? data.files.length : 0));
                              currentPath = data.current_path || '';
                              
                              const files = data.files || [];
                              
                              if (files.length === 0) {
                                  browser.innerHTML = '<div style="padding: 20px; text-align: center; color: #718096;">📂 No files found</div>';
                              } else {
                                  browser.innerHTML = files.map(file => {
                                      const escapedPath = file.path.replace(/'/g, "\\'");
                                      const escapedName = file.name.replace(/'/g, "\\'");
                                      const fileIcon = file.type === 'dir' ? '📁' : '📄';
                                      const fileSizeSpan = file.type === 'file' ? '<span style="color: #718096; font-size: 10px; margin-left: 8px;">(' + formatFileSize(file.size) + ')</span>' : '';
                                      const downloadButton = (file.type === 'file' && file.name !== '..') ? '<button class="btn" style="padding: 4px 8px; font-size: 10px; margin: 0;" onclick="downloadFile(\'' + escapedPath + '\', \'' + escapedName + '\'); event.stopPropagation();">⬇️</button>' : '';
                                      return '<div class="file-item" style="display: flex; justify-content: space-between; align-items: center;">' +
                                          '<div onclick="handleFileClick(\'' + escapedPath + '\', \'' + file.type + '\', \'' + escapedName + '\')" style="flex: 1; display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
                                              fileIcon + ' ' + file.name + fileSizeSpan +
                                          '</div>' +
                                          downloadButton +
                                      '</div>';
                                  }).join('');
                              }
                              
                              log('File browser updated successfully');
                          })
                          .catch(error => {
                              log('File loading error: ' + error.message);
                              if (browser) {
                                  browser.innerHTML = 
                                      '<div style="color: #e53e3e; padding: 15px; text-align: center;">' +
                                          '❌ Error loading files<br>' +
                                          '<small style="color: #666;">' + error.message + '</small><br>' +
                                          '<button class="btn" onclick="loadFiles(\'' + path + '\')" style="margin-top: 8px; font-size: 12px; padding: 6px 12px;">🔄 Retry</button>' +
                                      '</div>';
                              }
                          });
                      } catch (e) {
                          log('Unexpected error in loadFiles: ' + e.message);
                      }
                  }
                  
                  function formatFileSize(bytes) {
                      if (bytes === 0) return '0 B';
                      const k = 1024;
                      const sizes = ['B', 'KB', 'MB', 'GB'];
                      const i = Math.floor(Math.log(bytes) / Math.log(k));
                      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
                  }
                  
                  function handleFileClick(path, type, name) {
                      log('Clicked: ' + name + ' (type: ' + type + ', path: ' + path + ')');
                      if (type === 'dir') {
                          log('Navigating to directory: ' + path);
                          loadFiles(path);
                      } else {
                          log('File clicked: ' + name);
                      }
                  }
                  
                  function downloadFile(filePath, fileName) {
                      log('Downloading file: ' + fileName);
                      const url = '/api/download?path=' + encodeURIComponent(filePath);
                      const link = document.createElement('a');
                      link.href = url;
                      link.download = fileName;
                      document.body.appendChild(link);
                      link.click();
                      document.body.removeChild(link);
                      log('Download initiated for: ' + fileName);
                  }
                  
                  function refreshFiles() {
                      log('Manual refresh');
                      loadFiles(currentPath);
                  }
                  
                  // Initialize application
                  function initializeApp() {
                      log('🚀 Initializing AI Terminal application...');
                      loadFiles();
                      log('✅ Application initialized successfully');
                  }
                  
                  // Start app
                  if (document.readyState === 'loading') {
                      document.addEventListener('DOMContentLoaded', initializeApp);
                  } else {
                      initializeApp();
                  }
              </script>
          </body>
          </html>'''
                  
                  self.send_response(200)
                  self.send_header('Content-Type', 'text/html')
                  self.send_header('Cache-Control', 'no-cache')
                  self.end_headers()
                  formatted_html = html.format(session_name=session_name, session_color=session_color)
                  self.wfile.write(formatted_html.encode())
          
          if __name__ == '__main__':
              port = 8080
              print(f'Starting AI Terminal server on port {port}')
              print(f'Session: {os.environ.get("SESSION_NAME", "AI Terminal")}')
              try:
                  with socketserver.TCPServer(('', port), FileHandler) as httpd:
                      print(f'Server ready at http://localhost:{port}')
                      httpd.serve_forever()
              except Exception as e:
                  print(f'Error: {e}')
          PYEOF
          
          echo "AI Terminal ready!"
          echo "Session Name: $${SESSION_NAME}"
          echo "Session Color: $${SESSION_COLOR}"
          echo "Web UI: port 8080"
          echo "Terminal: port 7681"
          
          # Start Python server with access to both NFS mounts
          cd {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}
          echo "Starting Web UI on port 8080..."
          python3 /tmp/server.py &
          
          # Keep container running 
          echo "Web UI: port 8080"
          echo "Terminal: port 7681"
          echo "All services running!"
          tail -f /dev/null
        ports:
        - name: http
          containerPort: {{ .Values.service.targetPort }}
          protocol: TCP
        - name: webui
          containerPort: 8080
          protocol: TCP
        resources:
          {{- toYaml .Values.resources | nindent 10 }}
        env:
        - name: TERM
          value: {{ .Values.env.TERM | quote }}
        - name: SESSION_NAME
          value: {{ .Values.session.name | quote }}
        - name: SESSION_COLOR
          value: {{ .Values.session.color | quote }}
        - name: SESSION_USER
          value: {{ .Values.session.user | quote }}
        volumeMounts:
        {{- if .Values.mounts.k8sTmux.enabled }}
        - name: k8s-tmux-nfs
          mountPath: /mnt/k8s-tmux
        {{- end }}
        {{- if .Values.mounts.wiredQuill.enabled }}
        - name: wiredquill-nfs
          mountPath: /mnt/WiredQuill
        {{- end }}
        {{- if .Values.mounts.homeDirectory.enabled }}
        - name: home-directory-nfs
          mountPath: {{ .Values.mounts.homeDirectory.mountPath | default "/home/dev" }}
        {{- end }}
        {{- if .Values.persistence.enabled }}
        - name: app-storage
          mountPath: /mnt/storage
        {{- end }}
      volumes:
      {{- if .Values.mounts.k8sTmux.enabled }}
      - name: k8s-tmux-nfs
        nfs:
          server: {{ .Values.mounts.k8sTmux.nfs.server }}
          path: {{ .Values.mounts.k8sTmux.nfs.path }}
      {{- end }}
      {{- if .Values.mounts.wiredQuill.enabled }}
      - name: wiredquill-nfs
        nfs:
          server: {{ .Values.mounts.wiredQuill.nfs.server }}
          path: {{ .Values.mounts.wiredQuill.nfs.path }}
      {{- end }}
      {{- if .Values.mounts.homeDirectory.enabled }}
      - name: home-directory-nfs
        nfs:
          server: {{ .Values.mounts.homeDirectory.nfs.server }}
          path: {{ .Values.mounts.homeDirectory.nfs.path }}
      {{- end }}
      {{- if .Values.persistence.enabled }}
      - name: app-storage
        persistentVolumeClaim:
          claimName: {{ include "k8s-tmux.fullname" . }}-storage-pvc
      {{- end }}
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
