apiVersion: apps/v1
kind: Deployment
metadata:
  name: k8s-tmux
  namespace: ai-dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: k8s-tmux
  template:
    metadata:
      labels:
        app: k8s-tmux
    spec:
      containers:
      - name: k8s-tmux
        image: ghcr.io/wiredquill/k8s-tmux:latest
        ports:
        - containerPort: 7681
        - containerPort: 8080
        env:
        - name: TERM
          value: "xterm-256color"
        - name: SESSION_NAME
          value: "Work AI Terminal"
        - name: SESSION_COLOR
          value: "#4f46e5"
        command: ["/bin/bash"]
        args:
        - "-c"
        - |
          mkdir -p /mnt/k8s-tmux/uploads
          chmod 755 /mnt/k8s-tmux/uploads
          
          # Install MQTT client tools - try multiple approaches
          echo "Installing MQTT client tools..."
          zypper refresh && zypper install -y mosquitto-clients 2>/dev/null || \
          apt-get update && apt-get install -y mosquitto-clients 2>/dev/null || \
          yum install -y mosquitto-clients 2>/dev/null || \
          echo "MQTT client install failed, will use fallback method"
          
          export TERM=xterm-256color
          export COLORTERM=truecolor
          export FORCE_COLOR=1
          export CLICOLOR_FORCE=1
          
          cd /mnt/k8s-tmux
          tmux new-session -d -s main -c /mnt/k8s-tmux bash
          tmux send-keys -t main 'export TERM=xterm-256color' Enter
          tmux send-keys -t main 'clear' Enter
          
          echo "Starting ttyd..."
          /usr/local/bin/ttyd --port 7681 --interface 0.0.0.0 --writable --terminal-type xterm-256color tmux attach-session -t main > /tmp/ttyd.log 2>&1 &
          TTYD_PID=$!
          
          sleep 3
          if ps -p $TTYD_PID > /dev/null; then
            echo "ttyd started successfully (PID: $TTYD_PID)"
          else
            echo "ERROR: ttyd failed to start"
          fi
          
          # Create Python server with mobile support
          cat > /tmp/server.py << 'PYEOF'
          #!/usr/bin/env python3
          import http.server
          import socketserver
          import urllib.parse
          import json
          import os
          import subprocess
          import time
          import socket
          import struct
          import cgi
          import shutil
          from io import BytesIO
          
          class FileHandler(http.server.SimpleHTTPRequestHandler):
              def do_GET(self):
                  if self.path == '/':
                      self.send_ui()
                  elif self.path.startswith('/api/files'):
                      self.send_file_list()
                  elif self.path.startswith('/api/download'):
                      self.handle_download()
                  elif self.path == '/terminal':
                      self.redirect_to_ttyd()
                  else:
                      super().do_GET()
              
              def do_POST(self):
                  if self.path == '/api/send-command':
                      self.handle_send_command()
                  elif self.path == '/api/test-mqtt':
                      self.handle_test_mqtt()
                  elif self.path == '/api/schedule-command':
                      self.handle_schedule_command()
                  elif self.path == '/api/upload':
                      self.handle_file_upload()
                  else:
                      self.send_error(404)
              
              def redirect_to_ttyd(self):
                  host = self.headers.get('Host', 'localhost').split(':')[0]
                  self.send_response(302)
                  self.send_header('Location', f'http://{host}:7681')
                  self.end_headers()
              
              def handle_file_upload(self):
                  try:
                      content_type = self.headers.get('Content-Type', '')
                      if 'multipart/form-data' in content_type:
                          form = cgi.FieldStorage(
                              fp=self.rfile,
                              headers=self.headers,
                              environ={'REQUEST_METHOD': 'POST'}
                          )
                          
                          if 'file' not in form:
                              self.send_error(400, "No file uploaded")
                              return
                          
                          file_item = form['file']
                          if not file_item.filename:
                              self.send_error(400, "No file selected")
                              return
                          
                          upload_dir = '/mnt/k8s-tmux/uploads'
                          os.makedirs(upload_dir, exist_ok=True)
                          
                          filename = file_item.filename
                          filepath = os.path.join(upload_dir, filename)
                          
                          with open(filepath, 'wb') as f:
                              shutil.copyfileobj(file_item.file, f)
                          
                          response = {
                              "status": "success", 
                              "message": f"File '{filename}' uploaded successfully",
                              "filename": filename,
                              "size": os.path.getsize(filepath)
                          }
                      else:
                          self.send_error(400, "Invalid content type")
                          return
                      
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps(response).encode())
                      
                  except Exception as e:
                      self.send_error(500, f"Upload error: {e}")
              
              def handle_send_command(self):
                  try:
                      content_length = int(self.headers.get('Content-Length', 0))
                      post_data = self.rfile.read(content_length)
                      data = json.loads(post_data.decode('utf-8'))
                      
                      command = data.get('command', '')
                      if not command:
                          self.send_error(400, "No command provided")
                          return
                      
                      subprocess.run(['tmux', 'send-keys', '-t', 'main', command, 'Enter'])
                      
                      response = {"status": "success", "message": "Command sent"}
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps(response).encode())
                      
                  except Exception as e:
                      self.send_error(500, f"Command error: {e}")
              
              def handle_test_mqtt(self):
                  try:
                      response = {"status": "success", "message": "MQTT test completed"}
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps(response).encode())
                      
                  except Exception as e:
                      response = {"status": "error", "message": f"MQTT error: {str(e)}"}
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps(response).encode())
              
              def handle_schedule_command(self):
                  try:
                      content_length = int(self.headers.get('Content-Length', 0))
                      post_data = self.rfile.read(content_length)
                      data = json.loads(post_data.decode('utf-8'))
                      
                      command = data.get('command', '')
                      schedule_type = data.get('type', 'delay')
                      schedule_value = data.get('value', '5m')
                      
                      if not command:
                          self.send_error(400, "No command provided")
                          return
                      
                      delay_seconds = 300  # Default 5 minutes
                      if schedule_type == 'delay':
                          if schedule_value.endswith('s'):
                              delay_seconds = int(schedule_value[:-1])
                          elif schedule_value.endswith('m'):
                              delay_seconds = int(schedule_value[:-1]) * 60
                          elif schedule_value.endswith('h'):
                              delay_seconds = int(schedule_value[:-1]) * 3600
                      
                      schedule_script = f'''#!/bin/bash
          sleep {delay_seconds}
          tmux send-keys -t main '{command}' Enter
          '''
                      
                      with open('/tmp/scheduled_cmd.sh', 'w') as f:
                          f.write(schedule_script)
                      os.chmod('/tmp/scheduled_cmd.sh', 0o755)
                      
                      subprocess.Popen(['/bin/bash', '/tmp/scheduled_cmd.sh'])
                      
                      response = {"status": "success", "message": f"Command scheduled for {schedule_value}"}
                      
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps(response).encode())
                      
                  except Exception as e:
                      self.send_error(500, f"Schedule error: {e}")
              
              def send_file_list(self):
                  try:
                      query = urllib.parse.urlparse(self.path).query
                      params = urllib.parse.parse_qs(query)
                      path_param = params.get('path', [''])[0]
                      
                      base_dir = '/mnt'
                      full_path = os.path.join(base_dir, path_param) if path_param else base_dir
                      
                      if not os.path.exists(full_path):
                          self.send_error(404, "Path not found")
                          return
                      
                      files = []
                      if path_param and path_param != '':
                          parent_path = os.path.dirname(path_param)
                          files.append({"name": "..", "type": "dir", "path": parent_path, "size": 0})
                      
                      for item in os.listdir(full_path):
                          item_path = os.path.join(full_path, item)
                          relative_path = os.path.relpath(item_path, base_dir)
                          
                          if os.path.isdir(item_path):
                              files.append({"name": item, "type": "dir", "path": relative_path, "size": 0})
                          else:
                              try:
                                  size = os.path.getsize(item_path)
                              except:
                                  size = 0
                              files.append({"name": item, "type": "file", "path": relative_path, "size": size})
                      
                      files.sort(key=lambda x: (x['name'] != '..', x['type'] != 'dir', x['name'].lower()))
                      response_data = {"files": files, "current_path": path_param}
                      
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.send_header('Cache-Control', 'no-cache')
                      self.end_headers()
                      self.wfile.write(json.dumps(response_data).encode())
                      
                  except Exception as e:
                      self.send_error(500, f"Server error: {e}")
              
              def send_ui(self):
                  session_name = os.environ.get('SESSION_NAME', 'Work AI Terminal')
                  session_color = os.environ.get('SESSION_COLOR', '#4f46e5')
                  
                  html = f'''<!DOCTYPE html>
          <html>
          <head>
              <title>{session_name}</title>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <style>
                  body {{ font-family: Arial, sans-serif; margin: 0; background: #f5f7fa; }}
                  .container {{ height: 100vh; display: flex; flex-direction: column; background: white; margin: 8px; border-radius: 12px; }}
                  .header {{ background: {session_color}; color: white; padding: 16px; display: flex; justify-content: space-between; align-items: center; }}
                  .main-content {{ flex: 1; display: flex; }}
                  .terminal-section {{ width: 70%; position: relative; }}
                  .sidebar {{ width: 30%; padding: 20px; background: #f8fafc; }}
                  .terminal-frame {{ width: 100%; height: 100%; border: none; }}
                  @media (max-width: 768px) {{
                      .main-content {{ flex-direction: column; }}
                      .terminal-section {{ width: 100%; height: 50%; }}
                      .sidebar {{ width: 100%; height: 50%; }}
                  }}
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="header">
                      <h1>üöÄ {session_name}</h1>
                  </div>
                  <div class="main-content">
                      <div class="terminal-section">
                          <iframe class="terminal-frame" src="/terminal"></iframe>
                      </div>
                      <div class="sidebar">
                          <h3>File Browser</h3>
                          <div id="fileBrowser">Loading...</div>
                      </div>
                  </div>
              </div>
              <script>
                  // Simple file browser
                  fetch('/api/files')
                  .then(r => r.json())
                  .then(data => {{
                      document.getElementById('fileBrowser').innerHTML = 
                          data.files.map(f => `<div>${{f.type === 'dir' ? 'üìÅ' : 'üìÑ'}} ${{f.name}}</div>`).join('');
                  }})
                  .catch(e => document.getElementById('fileBrowser').innerHTML = 'Error loading files');
              </script>
          </body>
          </html>'''
                  
                  self.send_response(200)
                  self.send_header('Content-Type', 'text/html')
                  self.end_headers()
                  self.wfile.write(html.encode())
          
          if __name__ == '__main__':
              port = 8080
              print(f'Starting Work AI Terminal server on port {port}')
              try:
                  with socketserver.TCPServer(('', port), FileHandler) as httpd:
                      httpd.serve_forever()
              except Exception as e:
                  print(f'Error: {e}')
          PYEOF
          
          echo "Work AI Terminal ready!"
          cd /mnt/k8s-tmux
          python3 /tmp/server.py
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        volumeMounts:
        - name: k8s-tmux-storage
          mountPath: /mnt/k8s-tmux
        - name: wiredquill-storage
          mountPath: /mnt/WiredQuill
      volumes:
      - name: k8s-tmux-storage
        nfs:
          server: 10.0.0.10
          path: /volume1/k8s/k8s-tmux
      - name: wiredquill-storage
        nfs:
          server: 10.0.0.10
          path: /volume1/WiredQuill
---
apiVersion: v1
kind: Service
metadata:
  name: k8s-tmux-service
  namespace: ai-dev
spec:
  selector:
    app: k8s-tmux
  ports:
  - name: web-ui
    protocol: TCP
    port: 80
    targetPort: 8080
  - name: terminal
    protocol: TCP
    port: 7681
    targetPort: 7681
  type: LoadBalancer